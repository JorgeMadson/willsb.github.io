<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>William Barbosa</title>
 <link href="http://willsb.github.io/atom.xml" rel="self"/>
 <link href="http://willsb.github.io"/>
 <updated>2016-04-24T12:28:10-03:00</updated>
 <id>http://willsb.github.io</id>
 <author>
   <name>William Barbosa</name>
   <email>william.sb@hotmail.com</email>
 </author>

 
 <entry>
   <title>Episódio V - Navegação usando MvvmCross</title>
   <link href="http://willsb.github.io/xamarin/2016/04/23/episode-V"/>
   <updated>2016-04-23T00:00:00-03:00</updated>
   <id>http://willsb.github.io/xamarin/2016/04/23/episode-V</id>
   <content type="html">
&lt;p&gt;&lt;img src=&quot;/assets/covers/mvvmwhat.png&quot; alt=&quot;Cover&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;episdio-v---navegao-usando-mvvmcross&quot;&gt;Episódio V - Navegação usando MvvmCross&lt;/h3&gt;

&lt;p&gt;Esse post é a continuação da série sobre MvvmCross em Xamarin. Você pode ler os episódios anteriores &lt;a href=&quot;/xamarin/2016/02/10/index&quot;&gt;aqui&lt;/a&gt;. Também é recomendada a leitura do artigo Preparando uma PCL para Xamarin, que pode ser encontrado &lt;a href=&quot;/xamarin/2016/02/16/index&quot;&gt;aqui&lt;/a&gt;, onde eu explico sobre PCLs e o básico sobre assíncronia. No post de hoje iremos explicar o modelo de navegação do MvvmCross e entender um pouco como implementar modelos de navegação diferentes do que vem “de fábrica”. Vamos lá?&lt;/p&gt;

&lt;h3 id=&quot;como-a-navegao-acontece&quot;&gt;Como a navegação acontece?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/xamarin/2016/02/24/episode-II#navegao-presenter-h&quot;&gt;Eu mencionei no episódio II&lt;/a&gt;, ainda que superficialmente, como funciona a exibição de telas no MvvmCross. Cada ViewModel representa uma abstração e a View é como aquele VM deve ser exibida na tela. Como nem tudo do seu app acontece na mesma tela, é necessário controlar a ordem de exibição das telas (no nosso caso, ViewModels) de forma que elas apareçam em uma determinada ordem. Para tanto, o framework MvvmCross faz uso do método &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/b2fc5c108a9fc928aafb62081088e552834b980e/MvvmCross/Core/Core/ViewModels/MvxNavigatingObject.cs#L122-L135&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ShowViewModel&amp;lt;TViewModel&amp;gt;&lt;/code&gt;&lt;/a&gt;, método localizado na classe &lt;code class=&quot;highlighter-rouge&quot;&gt;MvxNavigatingObject&lt;/code&gt;. Ainda nesse post eu irei explicar o que são os parâmetros que esse método pode receber, mas por hora vamos entender o que acontece depois que o método é chamado.&lt;/p&gt;

&lt;p&gt;Primeiro precisamos entender que as VMs ficam na área compartilhada do código. Isso quer dizer que elas são independentes de código específico de plataforma. Basta estudar as plataformas mobile por algumas horas para perceber que os modelos de navegação são muito diferentes, afinal as apis expostas e as abordagens de gestão de memórias não são as mesmas. Isso quer dizer que por si só o código de PCL não será capaz de controlar a navegação. Para contornar isso, o MvvmCross faz uso de injeção de dependencia, um conceito que eu explicarei em detalhes no próximo artigo.&lt;/p&gt;

&lt;p&gt;Sendo assim, são necessários 3 métodos &lt;code class=&quot;highlighter-rouge&quot;&gt;ShowViewModel&lt;/code&gt; para sair da ViewModel e chegar na UI. O primeiro é o da classe &lt;code class=&quot;highlighter-rouge&quot;&gt;MvxNavigatingObject&lt;/code&gt;, que é chamado pelas nossas VMs. O segundo é o da interface &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/Views/IMvxViewDispatcher.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewDispatcher&lt;/code&gt;&lt;/a&gt;. A responsabilidade dessa interface é assegurar que uma outra interface, a &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Core/Core/Views/IMvxViewPresenter.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewPresenter&lt;/code&gt;&lt;/a&gt;, será chamada e que isso acontecerá no Thread de UI (por isso que a interface &lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewDispatcher&lt;/code&gt; também implementa a interface &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Platform/Platform/Core/IMvxMainThreadDispatcher.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxMainThreadDispatcher&lt;/code&gt;&lt;/a&gt;). Como já disse, o terceiro método é o método &lt;code class=&quot;highlighter-rouge&quot;&gt;Show&lt;/code&gt; da interface &lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewPresenter&lt;/code&gt;, responsável por efetivamente carregar a View.&lt;/p&gt;

&lt;h3 id=&quot;e-eu-preciso-implementar-tudo-isso&quot;&gt;E eu preciso implementar tudo isso?!&lt;/h3&gt;

&lt;p&gt;Não mesmo! Enquanto é muito importante entender como tudo isso funciona por baixo dos panos para ser capaz de escrever o seu código de forma mais eficaz, em aplicações simples é provável que você não precise implementar a interface &lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewPresenter&lt;/code&gt; (e mesmo em aplicações mais complexas você provavelmente não vai precisar implementar um &lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewDispatcher&lt;/code&gt;). Isso acontece porque o MvvmCross já tem essas interfaces implementadas para os casos mais comuns. Basta &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/search&quot;&gt;buscar no código fonte do MvvmCross&lt;/a&gt; por Mvx&lt;strong&gt;Nome da plataforma&lt;/strong&gt;ViewDispatcher para ver como é implementado o Dispatcher de cada uma das plataformas. Abaixo estão os links diretos para os dispatchers e os presenters. É interessante que você dê uma olhada no códigos fonte da plataforma que você tem mais familiaridade antes de prosseguir a leitura.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Android - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Droid/Droid/Views/MvxAndroidViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/4.0/MvvmCross/Droid/Shared/Presenter&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Console - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Console/Console/Views/MvxConsoleViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Console/Console/Views&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;iOS - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/iOS/iOS/Views/MvxIosViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/iOS/iOS/Views/Presenters&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Mac - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Mac/Mac/Views/MvxMacViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Mac/Mac/Views/Presenters&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;UWP - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/WindowsUWP/Views/MvxWindowsViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/WindowsUWP/Views&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Windows Phone - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/WindowsPhone/Views/MvxPhoneViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/WindowsPhone/Views&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Windows Store - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/WindowsStore/Views/MvxStoreViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/WindowsStore/Views&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;WPF - &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/Wpf/Views/MvxWpfViewDispatcher.cs&quot;&gt;Dispatcher&lt;/a&gt; // &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/tree/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Windows/Wpf/Views&quot;&gt;Presenters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ao olhar os dispatchers e os presenters você deve ter notado que enquanto os Dispatchers são todos muito similares (fazem o Marshal para o UI thread e encaminham a requisição para o presenter) os presenters geralmente são mais complexos, tendo cada plataforma a sua interface própria e, em certos casos, até mais de um presenter predefinido. Isso ocorre por dois motivos.  Primeiro porque as necessidades de exibição de ViewModel variam bastante entre cada plataforma suportada pelo MvvmCross. O segundo motivo é que apps diferentes tem necessidades complemente diferentes de exibição de conteúdo.&lt;/p&gt;

&lt;p&gt;Um app como o Snapchat exibe o seu conteúdo de uma forma completamente diferente do WhatsApp, por exemplo. Não tem como esperar que uma solução de exibição de ViewModels funcione para ambos da mesma maneira. Claro que o exemplo foi extremo, mas não precisamos ir tão longe: Se você quiser implementar conceitos que são relativamente comuns como o de &lt;a href=&quot;https://www.google.com/design/spec/components/bottom-navigation.html&quot;&gt;Bottom Navigation&lt;/a&gt; ou &lt;a href=&quot;https://www.google.com/design/spec/patterns/navigation-drawer.html&quot;&gt;Navigation Drawer&lt;/a&gt;, você precisa de um presenter com algumas alterações, já que os presenters padrão tratam ViewModels como páginas e esse nem sempre é o caso.&lt;/p&gt;

&lt;h3 id=&quot;uma-viewmodel-no--pgina-como-assim&quot;&gt;Uma ViewModel não é página? Como assim?!&lt;/h3&gt;

&lt;p&gt;Vou esperar você tomar uma água e se recuperar do choque. Não, uma ViewModel não representa uma página. Como dividir o app em páginas é o jeito mais comum de se desenvolver apps, geralmente essa abordagem de 1 página = 1 VM basta. Esse não é o caso sempre. Se você tem componentes que aparecem em mais de uma página (como no exemplo acima, um Navigation Drawer) faz sentido que esse componente seja representado por uma ViewModel e que o seu presenter o trate um pouco diferente.&lt;/p&gt;

&lt;p&gt;Usarei como exemplo a plataforma Android. Uma abordagem para implementar o Navigation Drawer seria criar um presenter que extende o &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/c6b3976e3025464005adb97df258c959a106d74a/MvvmCross/Droid/Shared/Presenter/MvxFragmentsPresenter.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxFragmentsPresenter&lt;/code&gt;&lt;/a&gt; e trata a VM que representa o Drawer de forma diferente. Já que o presenter do Android tem acesso à Activity que está sendo atualmente exibida, basta verificar o tipo da VM antes de exibir. Se for o tipo que precisa ser tratado de forma diferente, faça o que deve ser feito, caso contrário apenas chame o método base.&lt;/p&gt;

&lt;p&gt;Quando você começa a pensar que uma ViewModel é na verdade uma abstração de um pedaço da tela, fica bem mais fácil de entender esses conceitos. A ViewModel representa um pedaço da tela; o que acontece é que na maior parte das vezes esse pedaço ocupa a tela toda.&lt;/p&gt;

&lt;h3 id=&quot;s-tem-isso-de-possibilidade-de-customizao&quot;&gt;Só tem isso de possibilidade de customização?&lt;/h3&gt;

&lt;p&gt;Negativo, caro leitor. Te lembra dos parâmetros adicionais do método &lt;code class=&quot;highlighter-rouge&quot;&gt;ShowViewModel&lt;/code&gt;? Pois bem, você pode trata-los no seu presenter com o intuito de moldar a navegação de acordo com as necessidades do seu app. Os dois primeiros, parameterBundle e presentationBundle, são utilizados para passar informação para o seu presenter. O primeiro, obviamente, passa parâmetros e o segundo passa informações sobre a forma como os dados deverão ser apresentados. Um exemplo super prático disso pode ser visto &lt;a href=&quot;http://gregshackles.com/presenters-in-mvvmcross-manipulating-the-back-stack/&quot;&gt;nesse excelente artigo do Greg Shackles&lt;/a&gt; onde ele usa os bundles para sinalizar que a backstack deve ser esvaziada. O outro parâmetro é do tipo &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Core/Core/ViewModels/MvxRequestedBy.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxRequestedBy&lt;/code&gt;&lt;/a&gt; e serve para que o presenter tenha ciência de quem foi o ViewModel que solicitou a exibição. Isso pode ser útil para definir se a ViewModel que está sendo exibida deve entrar na backstack ou não, por exemplo.&lt;/p&gt;

&lt;p&gt;Além desses parâmetros, nós podemos ainda explorar o método &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/b2fc5c108a9fc928aafb62081088e552834b980e/MvvmCross/Core/Core/ViewModels/MvxNavigatingObject.cs#L27-L35&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ChangePresentation&lt;/code&gt;&lt;/a&gt;. Esse método serve para quando nós queremos sinalizar para o presenter que algo deve ser feito com a ViewModel atual. Esse método faz uso da classe &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Core/Core/ViewModels/MvxPresentationHint.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxPresentationHint&lt;/code&gt;&lt;/a&gt;, que permite que informações sejam enviadas para o presenter a qualquer momento. Um exemplo disso, que inclusive já é implementado por padrão no framework, é o método &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/b2fc5c108a9fc928aafb62081088e552834b980e/MvvmCross/Core/Core/ViewModels/MvxNavigatingObject.cs#L22-L25&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Close&lt;/code&gt;&lt;/a&gt;. Esse invoca o método &lt;code class=&quot;highlighter-rouge&quot;&gt;ChangePresentation&lt;/code&gt; passando uma &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/3c735adc534a5df2d4730e9d58a08f7863c30cee/MvvmCross/Core/Core/ViewModels/MvxClosePresentationHint.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxClosePresentationHint&lt;/code&gt;&lt;/a&gt;. Essa hint é por padrão tratada em todas as plataformas para encerrar a ViewModel atual, mostrando que apesar de simples esse padrão é extremamente eficaz e oferece um poder de customização enorme à plataforma.&lt;/p&gt;

&lt;h3 id=&quot;isso-tem-uso-na-vida-real&quot;&gt;Isso tem uso na vida real?&lt;/h3&gt;

&lt;p&gt;Com certeza! Apesar de tudo isso parecer algo abstrato e de outro mundo, quando você precisar de um custom presenter tudo fará sentido na sua cabela. Acredite, saber oque está nesse artigo é importante para quem quer fazer uma aplicação que vai além do feijão com arroz. No próximo artigo eu irei falar sobre injeção de dependencias, um tema crucial para quem quer fazer apps com MvvmCross. Espero que tenham gostado e até a próxima :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Episódio IV - Data Binding em MvvmCross 102</title>
   <link href="http://willsb.github.io/xamarin/2016/04/03/episode-IV"/>
   <updated>2016-04-03T00:00:00-03:00</updated>
   <id>http://willsb.github.io/xamarin/2016/04/03/episode-IV</id>
   <content type="html">
&lt;p&gt;&lt;img src=&quot;/assets/covers/mvvmwhat.png&quot; alt=&quot;Cover&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;episdio-iv---data-binding-em-mvvmcross-102&quot;&gt;Episódio IV - Data Binding em MvvmCross 102&lt;/h3&gt;

&lt;p&gt;Esse post é a continuação da série sobre MvvmCross em Xamarin. Você pode ler os episódios anteriores &lt;a href=&quot;/xamarin/2016/02/11/episode-I&quot;&gt;aqui&lt;/a&gt;, &lt;a href=&quot;/xamarin/2016/02/24/episode-II&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;/xamarin/2016/03/14/episode-III&quot;&gt;aqui&lt;/a&gt;. Também é recomendada a leitura do artigo Preparando uma PCL para Xamarin, episódios &lt;a href=&quot;/xamarin/2016/02/17/episode-I&quot;&gt;I&lt;/a&gt; e &lt;a href=&quot;&quot;&gt;II&lt;/a&gt;, onde eu explico sobre PCLs e o básico sobre assíncronia. O post de hoje é uma continuação direta do último, onde iremos falar sobre outros aspectos do DataBinding. Vamos lá?&lt;/p&gt;

&lt;h3 id=&quot;ainda-tem-coisa-para-falar&quot;&gt;Ainda tem coisa para falar?&lt;/h3&gt;

&lt;p&gt;Sim, muitas! DataBinding é um assunto extenso e apesar do último post ter tratado de muitos assuntos nós ainda temos muito o que aprender. Algo que não é claro inicialmente é que o DataBinding implica que as propriedades da sua VM e da sua View possuam o mesmo tipo. Isso nem sempre é possível (afinal, a VM estará em uma PCL, que não tem acesso a todos os tipos nativos da sua View), portanto existem momentos em que será necessário utilizar um recurso chamado ValueConverters. Outra coisa que veremos é como fazer o binding entre uma ação, usando os Commands!&lt;/p&gt;

&lt;h3 id=&quot;quando-e-por-que-usar-valueconverters&quot;&gt;Quando e por que usar ValueConverters?&lt;/h3&gt;

&lt;p&gt;ValueConverters são um mecanismo que permite que os valores da VM sejam convertidos antes de serem atríbuidos à View e vice-versa. Em um modelo de Binding padrão do .net Framework, implementa-se a interface &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.windows.data.ivalueconverter(v=vs.110).aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IValueConverter&lt;/code&gt;&lt;/a&gt; e os métodos &lt;code class=&quot;highlighter-rouge&quot;&gt;Convert&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;ConvertBack&lt;/code&gt; são responsáveis por converter os valores, respectivamente, entre VM e View e View e VM. Como essa interface não é feita para ser portátil, o MvvmCross introduz sua própria interface, a &lt;a href=&quot;&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxValueConverter&lt;/code&gt;&lt;/a&gt;, que serve para o mesmo propósito da interface &lt;code class=&quot;highlighter-rouge&quot;&gt;IValueConverter&lt;/code&gt;, mas que permite que os Converters existam na sua PCL, sendo assim reutilizáveis em todas plataformas suportadas¹!&lt;/p&gt;

&lt;p&gt;O funcionamento do Converter é intuitívo. Você recebe um valor e transforma em outro no método Convert. O método ConvertBack serve para fazer o caminho oposto. Note que nesses métodos é passado, além do valor que será usado na conversão, outros três parametros: type, parameter e culture. O primeiro indica o Tipo para qual você está convertendo (afinal essas interfaces recebem e retornam &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;) e o terceiro indica a Cultura do dispositivo (com o intuito de permitir coisas como i18n dentro dos converters). O único que precisa ser explicado é o segundo. Ele é chamado de “ConverterParameter”, e ele serve para que a View forneça alguma informação para o converter. Vamos supor que o seu ValueConverter deva agir de um jeito em uma tela e de um outro jeito ligeiramente diferente em outra. Ao invés de criar dois ValueConverters, você indica qual é o ConverterParameter durante o Binding, permitindo assim que o seu ValueConverter execute de acordo com cada situação.&lt;/p&gt;

&lt;p&gt;Antes de criar um ValueConverter, é necessário pensar que a ViewModel serve exatamente para modelar os dados das Models de uma maneira que a exibição dos mesmos seja facilitada. Portanto, é importante que você verifique que há realmente uma necessidade em fazer aquilo. Eu gosto de pensar que os ValueConverters são parte da View, então os motivos de criação deles geralmente são referentes à exibição dos dados. Alguns bons motivos para criar um ValueConverter:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O tipo de valor que você quer bindar não existe na sua PCL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Esse é o exemplo do &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross-Plugins/blob/master/Visibility/MvvmCross.Plugins.Visibility/MvxBaseVisibilityValueConverter.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxVisibilityValueConverter&lt;/code&gt;&lt;/a&gt;. Cada plataforma tem um jeito específico de definir o que é visivel e o que não é. Portanto esse plugin faz uma ponte entre a sua VM e a sua UI, permitindo a conversão de booleanos, strings e números para os valores nativos que representam Visível e Invisível.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algum ponto da exibição dos dados é específica de uma plataforma&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Temos sempre que lembrar que o Xamarin é feito para permitir e facilitar o reuso de código e não para gerar aplicações idênticas. As vezes a View do iOS é diferente da View do Android e isso é perfeitamente normal. Nesse caso, ao invés de colocar a lógica que diferencia ambas na ViewModel, que tem que ser agnostica a plataforma, criamos um ValueConverter. Um exemplo prático disso é se temos um nome muito grande que é exibido na tela. Em um tablet, podemos exibi-lo por completo. Já em celulares, criamos um converter que exibe apenas o primeiro nome e a abreviação do sobrenome.&lt;/p&gt;

&lt;p&gt;Existem outros, sem dúvida, mas estes são apenas alguns para ilustrar o meu ponto. É importante não criar ValueConverters indiscriminadamente, pois assim você só aumenta a complexidade do seu app, as vezes sem um bom motivo. É importante também manter em mente que os ValueConverters, assim como muitos outros elementos do MvvmCross, devem ser tão genéricos quanto possível. Se puder criar um converter dentro da sua PCL, crie lá, pois você pode precisar dele em mais de uma plataforma.&lt;/p&gt;

&lt;h3 id=&quot;e-como-eu-fao-para-utiliza-los&quot;&gt;E como eu faço para utiliza-los?&lt;/h3&gt;

&lt;p&gt;Depois que você decidiu que criar o Converter é necessário, extenda a classe &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Platform/Platform/Converters/MvxValueConverter.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxValueConverter&amp;lt;TFrom, TTo&amp;gt;&lt;/code&gt;&lt;/a&gt; (que existe apenas para conveniencia; você pode implementar a interface diretamente se quiser). Por questões de padronização, é importante adicionar o sufixo “Converter” ao nome do seu ValueConverter. Feito isso, para utiliza-lo basta usar ele como se fosse uma chamada de método nos Bindings de Android, &lt;strong&gt;omitindo o sufixo converter ao faze-lo&lt;/strong&gt;. O primeiro parametro é o valor a ser convertido e o segundo (se você passa-lo) é o ConverterParameter. Note que você pode fazer o encadeamento de vários converters no processo:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Neste exemplo, a propriedade Text está bound com a propriedade Name. Antes de exibir a informação, o converter FirstNameConverter é chamado, e o ConverterParameter é o número 0
local:MvxBind=&quot;Text FirstName(Name, 0)&quot;
//Neste exemplo, o valor passa por dois ValueConverters antes da atribuição
local:MvxBind=&quot;Text Caps(FirstName(Name))&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Se está usando FluentBindings, usar converters é tão fácil quanto. Use o método &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Binding/BindingContext/MvxFluentBindingDescription.cs#L224&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WithConversion&lt;/code&gt;&lt;/a&gt; após o método &lt;code class=&quot;highlighter-rouge&quot;&gt;To()&lt;/code&gt;, passando como parametros uma instância do seu ValueConverter e, se aplicável, o ConverterParameter.&lt;/p&gt;

&lt;h3 id=&quot;e-se-eu-quiser-fazer-algo-ao-invs-de-exibir-algo&quot;&gt;E se eu quiser fazer algo ao invés de exibir algo?&lt;/h3&gt;

&lt;p&gt;Que bom que perguntou! Eu já disse &lt;a href=&quot;xamarin/2016/02/24/episode-II#por-onde-tudo-isso--inicializado&quot;&gt;anteriormente&lt;/a&gt; que toda a navegação do seu app deveria ser controlada pelo MvvmCross. Que legal, temos mais uma coisa que será compartilhada! Mas como isso acontece? Também com DataBinding!&lt;/p&gt;

&lt;p&gt;Para esse caso (e para muitos outros) é importante nos aprofundarmos um pouco mais na maneira como o Binding funciona. Até o momento nós usamos apenas binds simples: a propriedade da ViewModel se liga diretamente à propriedades que tem um getter e um setter e às atualizam por meio da interface &lt;code class=&quot;highlighter-rouge&quot;&gt;INotifyPropertyChanged&lt;/code&gt;. Para muitos casos isso não basta. É o caso do evento de &lt;a href=&quot;https://developer.xamarin.com/api/event/Android.Views.View.Click/&quot;&gt;Click&lt;/a&gt;. Por não ser uma propriedade, e sim um evento, por padrão não tem como fazer um binding nela. Para isso o MvvmCross usa a interface &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Binding/Bindings/IMvxBinding.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxBinding&lt;/code&gt;&lt;/a&gt;. Ela serve para permitir usos de Binding que vão além do básico que já vimos.&lt;/p&gt;

&lt;p&gt;O Binding de Click em específico usa a interface &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Binding/Bindings/Target/IMvxTargetBinding.cs&quot;&gt;IMvxTargetBinding&lt;/a&gt; (que provavelmente é a Interface que você vai implementar quando precisar de um Binding customizado, seja diretamente, extendendo a classe abstrata &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Binding/Bindings/Target/MvxTargetBinding.cs&quot;&gt;MvxTargetBinding&lt;/a&gt; ou as classes específicas de cada plataforma). Essa interface nos dá meios de criar uma classe capaz de se ligar à View, alterando suas propriedades ou se inscrevendo em seus eventos, enquanto recebe e envia atualizações para a ViewModel. O binding de Click, cujo fonte você pode ver &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Binding/Droid/Target/MvxViewClickBinding.cs&quot;&gt;aqui&lt;/a&gt; faz exatamente isso: ele se inscreve no evento de Click da View e chama o Command, que é atualizado de acordo com a ViewModel no método &lt;code class=&quot;highlighter-rouge&quot;&gt;SetValue&lt;/code&gt;. Wow! Parece trabalhoso, mas é muito mais simples de se fazer do que de se explicar. Veremos como implementar um Binding customizado nessa série, então segure a animação.&lt;/p&gt;

&lt;h3 id=&quot;o-que--esse-tal-de-command&quot;&gt;O que é esse tal de Command?&lt;/h3&gt;

&lt;p&gt;Commands são classes que implementam a interface &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.windows.input.icommand(v=vs.110).aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ICommand&lt;/code&gt;&lt;/a&gt;. Eles são o jeito de criar ações usando o padrão MVVM. Essa interface tem dois métodos, um que contém o código que é executado e um que diz se o comando pode ou não ser executado, e um evento que dispara toda vez que o estado de permissão de execução muda.&lt;/p&gt;

&lt;p&gt;Essa interface, contudo, dificilmente precisará ser implementada diretamente. Ao trabalhar com MvvmCross, recomenda-se utilizar a interface &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/ViewModels/IMvxCommand.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxCommand&lt;/code&gt;&lt;/a&gt; na hora de definir os Commands da sua ViewModel e usar os tipos &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/ViewModels/MvxCommand.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxCommand&lt;/code&gt;&lt;/a&gt; e o &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/ViewModels/MvxCommand.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxAsyncCommand&lt;/code&gt;&lt;/a&gt; (bem como suas variantes genéricas) na hora de efetivamente instanciar os Commands. Esses tipos cobrem a maior parte dos casos, então você dificilmente precisava implementar essa interface na mão.&lt;/p&gt;

&lt;p&gt;Uma vez que seu command está devidamente criado e pode ser executado, basta fazer um Binding usando a palavra “Click”. Sim, é só isso! No android ficaria assim:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local:MvxBind=&quot;Click MyCommand&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Já no FluentBinding, assim:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set.Bind(button).For(&quot;Click&quot;).To(vm =&amp;gt; vm.MyCommand);²
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;agora-no-tem-mais-o-que-falar-n&quot;&gt;Agora não tem mais o que falar, né?&lt;/h3&gt;

&lt;p&gt;Ainda tem MUITO o que falar! Esse assunto é extenso demais! Porém não só de binding viverá o homem, então no próximo post eu falarei sobre navegação e presenters, um assunto que será mais importante do que ser um mestre Jedi em DataBinding. Não se preocupe, porém, eu voltarei a falar de DataBinding mais pra frente. Por hora, uma última dica é olhar o método &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/4.0/MvvmCross/Binding/Droid/MvxAndroidBindingBuilder.cs#L80&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FillTargetFactories&lt;/code&gt;&lt;/a&gt; que fica dentro de MvvmCross/MvvmCross/Binding/[Plataforma]/Mvx[Plataforma]BindingBuilder. Irei explicar futuramente o funcionamente exato desse método, mas só de olhar esse método você consegue ter uma ideia. Essas strings que você vê são os bindings padrão do MvvmCross. Isso quer dizer que você pode usa-las no seu projeto! Tem muita coisa legal e que nós nem imaginamos, como o bind de &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Binding/Droid/Target/MvxRatingBarRatingTargetBinding.cs&quot;&gt;Rating&lt;/a&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;Por hora é isso, aguardo vocês na próxima :)&lt;/p&gt;

&lt;p&gt;¹ - Sim, todas mesmo! Para plataformas que usam a interface &lt;code class=&quot;highlighter-rouge&quot;&gt;IValueConverter&lt;/code&gt;, como o WPF, você pode usar a classe &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Platform/WindowsCommon/Converters/MvxNativeValueConverter.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxNativeValueConverter&lt;/code&gt;&lt;/a&gt;, que cria um wrapper no seu &lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxValueConverter&lt;/code&gt; e permite a sua utilização diretamente nos Bindings do XAML.&lt;/p&gt;

&lt;p&gt;² - Click é o binding “default” das views que são botões em suas plataformas. Desse modo, poderiamos também simplesmente não usar o método &lt;code class=&quot;highlighter-rouge&quot;&gt;For&lt;/code&gt; e obter o mesmo resultado. Não recomendo fazer isso, contudo, pois requer um conhecimento prévio que nem todos do projeto podem ter (a menos que você faça e coloque um link para esse artigo, hehe).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Episódio III - Data Binding em MvvmCross 101</title>
   <link href="http://willsb.github.io/xamarin/2016/03/14/episode-III"/>
   <updated>2016-03-14T00:00:00-03:00</updated>
   <id>http://willsb.github.io/xamarin/2016/03/14/episode-III</id>
   <content type="html">
&lt;p&gt;&lt;img src=&quot;/assets/covers/mvvmwhat.png&quot; alt=&quot;Cover&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;episdio-iii---data-binding-em-mvvmcross-101&quot;&gt;Episódio III - Data Binding em MvvmCross 101&lt;/h3&gt;

&lt;p&gt;Esse post é a continuação da série sobre MvvmCross em Xamarin. Você pode ler os episódios anteriores &lt;a href=&quot;/xamarin/2016/02/11/episode-I&quot;&gt;aqui&lt;/a&gt; e &lt;a href=&quot;/xamarin/2016/02/24/episode-II&quot;&gt;aqui&lt;/a&gt;. Também é recomendada a leitura do artigo Preparando uma PCL para Xamarin, episódios &lt;a href=&quot;/xamarin/2016/02/17/episode-I&quot;&gt;I&lt;/a&gt; e &lt;a href=&quot;&quot;&gt;II&lt;/a&gt;, onde eu explico sobre PCLs e o básico sobre assíncronia. Esse post tem como intuito ensinar um dos mecanismos mais importantes do padrão MVVM: Data Binding. Iremos ver como esse processo funciona de forma geral (na arquitetura MVVM) e como é a implementação de DataBinding do MvvmCross. Vamos lá?&lt;/p&gt;

&lt;h3 id=&quot;data-binding&quot;&gt;Data Binding?&lt;/h3&gt;

&lt;p&gt;Data Binding é o mecanismo que fornece ao padrão MVVM uma das suas maiores forças, que é a capacidade de unir a ViewModel e a View. De forma simplificada, Data Binding nada mais é do que atrelar propriedades de um objeto fonte (no nosso caso, uma ViewModel) à propriedades de outro objeto (no nosso caso, uma View) com o intuito de mante-las sempre em sincronia. Em outras palavras ao atualizar o valor de uma propriedade na nossa VM, o objeto fonte, esse valor será alterado também na nossa View, permitindo assim que alterações feitas na ViewModel sejam refletidas na interface da nossa aplicação!&lt;/p&gt;

&lt;p&gt;Voltando um pouco no que já foi dito, lembre-se que o projeto &lt;code class=&quot;highlighter-rouge&quot;&gt;Core&lt;/code&gt; é reutilizado em todas as plataformas e nossas ViewModels estão nele. Com o poder do DataBinding, ao alterar o valor de uma propriedade da sua ViewModel, você consegue alterar valores da sua interface. Isso adiciona ainda mais possibilidades de reuso de código, tendo em vista que agora você pode controlar os valores que aparecem para o usuário em todas as plataformas que você pretende suportar em um único ponto.&lt;/p&gt;

&lt;h3 id=&quot;e-como--que-isso-funciona&quot;&gt;E como é que isso funciona?&lt;/h3&gt;

&lt;p&gt;Lembra quando eu disse no episódio I que o padrão MVVM foi criado pela Microsoft? Pois então, o .net framework possui algumas funcionalidades que facilitam a implementação do DataBinding, como a interface &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INotifyPropertyChanged&lt;/code&gt;&lt;/a&gt; e o sistema de eventos. Uma classe que implementa &lt;code class=&quot;highlighter-rouge&quot;&gt;INotifyPropertyChanged&lt;/code&gt; (uma ViewModel) deve se preocupar em chamar o evento &lt;code class=&quot;highlighter-rouge&quot;&gt;PropertyChanged&lt;/code&gt; sempre que o valor de uma propriedade for alterado. Ao fazer isso, todos os objetos que assinaram esse evento (Views) serão notificados dessa alteração e poderão tomar uma ação (no caso, atualizar a interface do usuário).&lt;/p&gt;

&lt;p&gt;Um exemplo de como a interface é implementada pode ser visto na classe &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/ViewModels/MvxNotifyPropertyChanged.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxNotifyPropertyChanged&lt;/code&gt;&lt;/a&gt;. O método &lt;code class=&quot;highlighter-rouge&quot;&gt;RaisePropertyChanged&lt;/code&gt; chama o evento &lt;code class=&quot;highlighter-rouge&quot;&gt;PropertyChanged&lt;/code&gt; indicando qual propriedade foi alterada. Do outro lado, o mecanismo de binding percebe a alteração e atualiza os valores que são exibidos na tela. Tudo isso acontece de forma transparente (lembre-se que a ViewModel nem sabe que a View existe) então você não precisa se preocupar com a View em momento algum. A única coisa que você precisa fazer é se certificar que as propriedades que representam valores exibidos na View sejam implementadas assim:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private string _name;
public string Name
{
    get
    {
        return _name;
    }
    set
    {
        if (_name != value)
        {
            _name = value;
            RaisePropertyChanged();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nesse exemplo, o método &lt;code class=&quot;highlighter-rouge&quot;&gt;RaisePropertyChanged()&lt;/code&gt; é chamado sem nenhum parametro pois ele faz uso do &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.callermembernameattribute(v=vs.110).aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CallerMemberNameAttribute&lt;/code&gt;&lt;/a&gt;, que faz com que o valor do parametro anotado seja o nome do método que o chamou (no exemplo, “Name”). Isso deixa o código mais limpo, evitando que você tenha que explicitamente criar uma string para cada propriedade da VM. Se contudo você precisa notificar a alteração de uma propriedade em outro lugar, você pode fazer isso passando diretamente o nome da propriedade como uma string ou usando uma expressão lambda que passe o nome da propriedade que precisa ser alterada, como no exemplo abaixo:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//O valor dessa propriedade é dependente do valor da propriedade &quot;IsLoggedIn&quot;, por isso ela possui apenas o get
public string Message
{
    get
    {
        return IsLoggedIn ? &quot;Seja bem-vindo!&quot; : &quot;Faça login para prosseguir&quot;;
    }
}

//Essa propriedade indica se o usuário fez login
private string _isLoggedIn;
public string IsLoggedIn
{
    get
    {
        return _isLoggedIn;
    }
    set
    {
        if (_isLoggedIn != value)
        {
            _isLoggedIn = value;
            RaisePropertyChanged();
            //Avisa a View que a propriedade Message foi alterada
            RaisePropertyChanged(() =&amp;gt; Message);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Se você se sente incomodado com esse boilerplate, você não é o único. Para evitar a digitação desse monte de código, pode usar o &lt;a href=&quot;https://github.com/Fody/Fody&quot;&gt;Fody&lt;/a&gt;, que vai “tecer” as &lt;a href=&quot;https://github.com/Fody/PropertyChanged&quot;&gt;chamadas ao &lt;code class=&quot;highlighter-rouge&quot;&gt;RaisePropertyChanged&lt;/code&gt; na IL do seu código&lt;/a&gt; ou pode usar esse &lt;a href=&quot;/content/mvx.snippet&quot;&gt;template&lt;/a&gt; (tirado &lt;a href=&quot;http://stackoverflow.com/a/22110796/3465182&quot;&gt;desta resposta&lt;/a&gt;) no Visual Studio para que ele gere esse código base com o atalho &lt;code class=&quot;highlighter-rouge&quot;&gt;mvxprop&lt;/code&gt; + tab duas vezes. Importar o template no VS é muito simples e é deixado como um exercício para o leitor :)&lt;/p&gt;

&lt;h3 id=&quot;como-declarar-os-bindings-usando-mvvmcross&quot;&gt;Como declarar os bindings usando MvvmCross?&lt;/h3&gt;

&lt;p&gt;O processo de declaração dos bindings pode ser feito tanto nas linguagens de Markup (.axml no Android e .xaml nas plataformas Windows) quanto no codebehind de cada plataforma. A regra geral é sempre tentar fazer o máximo possível no Markup (afinal assim você deixa suas intenções muito mais claras e legíveis) e só usar o FluentBinding quando você precisar.&lt;/p&gt;

&lt;p&gt;Para os que estão acostumados com XAML, o MvvmCross faz uso do mesmo modelo de binding, o que facilita muito para quem já usa MVVM mas nunca usou este framework. Não vou me aprofundar nesse tema pois já existe muito material pronto sobre isso na internet, então vou apenas deixar &lt;a href=&quot;https://blogs.msdn.microsoft.com/jerrynixon/2012/10/12/xaml-binding-basics-101/&quot;&gt;esse link&lt;/a&gt; que é um excelente material introdutório.&lt;/p&gt;

&lt;p&gt;Já no Android, os bindings feitos no markup são simples porém muito expressivos. Primeiro você precisa declarar o namespace &lt;code class=&quot;highlighter-rouge&quot;&gt;local&lt;/code&gt; no nó pai do seu xml (&lt;code class=&quot;highlighter-rouge&quot;&gt;xmlns:local=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/code&gt;). Em seguida, você vai usar o atributo &lt;code class=&quot;highlighter-rouge&quot;&gt;MvxBind&lt;/code&gt; em cada uma das  Views onde você quer realizar o binding. O valor do atributo é uma string que segue o seguinte formato &lt;code class=&quot;highlighter-rouge&quot;&gt;PropriedadeDaView PropriedadeDaViewModel&lt;/code&gt;, sendo que caso você queira multiplas propriedades deve separar cada uma delas por vírgula. A sintaxe final fica assim:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:local=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&amp;gt;

    &amp;lt;TextView
    	local:MvxBind=&quot;Text FirstName&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;/&amp;gt;

    &amp;lt;Button
    	local:MvxBind=&quot;Text WelcomeText; Click LoginCommand&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Para quem é acostumado com xml de Android mas não conhece nada de MvvmCross, o trecho acima é bem simples de ser lido. Estou expressando que o texto da primeira TextView será igual ao valor da propriedade &lt;code class=&quot;highlighter-rouge&quot;&gt;FirstName&lt;/code&gt; da ViewModel¹. Limpo, claro e conciso. Sério, é só isso. Contanto que a view tenha uma propriedade com getter e setter, tudo que você precisa fazer é isso: Escrever o nome daquela propriedade e o nome da propriedade da VM e o motor do MvvmCross vai se virar para criar os bindings e manter aquele valor atualizado. Existem mais possibilidades para esse tipo de binding que iremos ver no próximo post!&lt;/p&gt;

&lt;h3 id=&quot;e-quando-no-tem-como-fazer-no-xml&quot;&gt;E quando não tem como fazer no xml?&lt;/h3&gt;

&lt;p&gt;Para o iOS, onde o binding no Markup não está disponível, e para alguns casos onde não tem como você fazer o binding diretamente no xml, devemos usar o chamado FluentBinding para criar as relações entre View e ViewModel. O processo é bem simples. Você primeiro cria um &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Binding/BindingContext/MvxFluentBindingDescriptionSet.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxFluentBindingDescriptionSet&lt;/code&gt;&lt;/a&gt; usando o método de extensão &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Binding/BindingContext/MvxBindingContextOwnerExtensions.Fluent.cs#L12-L17&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateBindingSet&lt;/code&gt;&lt;/a&gt;. Uma vez criado, você deve usar os métodos da interface da seguinte forma:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var set = this.CreateBindingSet&amp;lt;MyView, MyViewModel&amp;gt;();
set
.Bind(editText) //View que será usada no binding
.For(v =&amp;gt; v.Text) // expressão lambda (ou string) que indica qual propriedade da View será usada no binding
.To(vm =&amp;gt; vm.FirstName); //expressão lambda (ou string) que indica qual propriedade da ViewModel será usada no binding

//Similar ao acima, mas em uma linha :)
set.Bind(button).For(v =&amp;gt; v.Text).To(vm =&amp;gt; vm.WelcomeText);

//Se esquecer de chamar o Apply, nada acontecerá!
set.Apply()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Como você pode ver, existem alguns problemas no FluentBinding que não existem no binding de texto. Um deles é a sintaxe, que é fácil de esquecer/confundir. Outro é a quantidade de código que você precisa. Não é muito, mas se você pode descrever a mesma coisa usando menos no xml, não tem motivo para não faze-lo. Tirando esses pequenos problemas (que só existem se você estiver comparando com a alternativa que é usar o binding de texto), usar a sintaxe fluente não é nada de outro planeta, portanto não se sinta intimidado!&lt;/p&gt;

&lt;h3 id=&quot;esse-post-foi-grande-hein&quot;&gt;Esse post foi grande, hein?&lt;/h3&gt;

&lt;p&gt;Sim, bem maior que o de costume. E eu ainda nem esgotei o assunto! Portanto leia tudo, dê um tempo para que seu cérebro absorva o conteúdo e depois leia novamente para fixação! Nos próximos posts vamos continuar falando de DataBinding, mas desta vez iremos tratar de bindings customizados (para necessidade mais específicas), Commands (usados para bindar ações ao invés de valores) e ValueConverters (que transformam o valor antes de exibi-lo). Portanto fique ligado porque vem muita coisa legal pela frente :)&lt;/p&gt;

&lt;p&gt;¹ - O MvvmCross localiza as ViewModels com base no nome da View, portanto se você criar a &lt;code class=&quot;highlighter-rouge&quot;&gt;FirstView&lt;/code&gt;, ele vai saber que o contexto dos bindings daquela View deve ser uma instância da classe &lt;code class=&quot;highlighter-rouge&quot;&gt;FirstViewModel&lt;/code&gt;. Esse comportamento pode ser alterado implementando o tipo &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/ViewModels/IMvxNameMapping.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxNameMapping&lt;/code&gt;&lt;/a&gt; e alterando o retorno padrão do método &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/Platform/MvxSetup.cs#L283&quot;&gt;CreateViewToViewModelNaming&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Episódio II - A importância de usar async</title>
   <link href="http://willsb.github.io/xamarin/2016/03/02/episode-II"/>
   <updated>2016-03-02T00:00:00-03:00</updated>
   <id>http://willsb.github.io/xamarin/2016/03/02/episode-II</id>
   <content type="html">
&lt;p&gt;&lt;img src=&quot;/assets/covers/pclasync.png&quot; alt=&quot;Cover&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;episdio-ii---a-importncia-de-usar-async&quot;&gt;Episódio II - A importância de usar async&lt;/h3&gt;

&lt;p&gt;Na episódio passado, falamos sobre PCLs e seus usos para o desenvolvimento cross mobile. Elas são uteis pois aumentam o reuso de código, reduzindo assim a dor de cabeça na hora de corrigir bugs e melhorando a manutenibilidade do seu projeto como um todo. Um dos pontos cruciais na hora de criar uma PCL é instalar os Nugets de async e de http. A parte de rede é fácil de entender (boa parte das aplicações podem ser resumidas em pegar dados do servidor e exibi-los na tela) e nesse post iremos entender porque o pacote de assincronia é tão importante quanto.&lt;/p&gt;

&lt;h3 id=&quot;async&quot;&gt;Async?&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; é um modificador que foi adicionado no versão 5 do C#. Ele, em par com o operador &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;, existem para facilitar o uso de código assíncrono escrito em C#. O uso dessa feature facilita e muito a programação assincrona. Código que antes precisaria de um callback (uma função que é executada quando a primeiro termina, de forma a permitir que o código prossiga de forma linear) agora pode ser escrito em sequência.&lt;/p&gt;

&lt;p&gt;Funções que usam o modificador &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; devem retornar uma &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.tasks.task%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt;&lt;/a&gt; ou uma &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd321424%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Task&amp;lt;TResult&amp;gt;&lt;/code&gt;&lt;/a&gt;. Isso acontece porque uma &lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt; é algo a ser resolvido (um conceito chamado future), então toda a parte de assincronia da linguagem foi construída com base no uso dela.&lt;/p&gt;

&lt;p&gt;Uma única exceção disso é que métodos &lt;code class=&quot;highlighter-rouge&quot;&gt;void&lt;/code&gt; podem ser &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;. Isso ocorre em parte porque você pode precisar utilizar &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; dentro de eventos ou métodos de um framework. Existe pequenas diferenças entre &lt;code class=&quot;highlighter-rouge&quot;&gt;async void&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;async Task&lt;/code&gt;, e elas são melhor explicadas &lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/jj991977.aspx&quot;&gt;neste artigo&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;e-por-que-isso--to-importante&quot;&gt;E por que isso é tão importante?&lt;/h3&gt;

&lt;p&gt;Quando se desenvolve para Xamarin, é muito fácil esquecer que o seu código irá rodar em celulares, mas é muito importante manter isso em mente o tempo todo. Lembre-se que celulares são limitados em termos de memória e bateria, portanto seu app &lt;strong&gt;não pode travar a thread principal, que é a responsável pela UI.&lt;/strong&gt; Muitas pessoas esquecem disso e acabam com um app que trava por vários segundos enquanto você acessa a internet ou faz algum processamento pesado, o que é frustrante para o usuário, que acha que seu app deu &lt;em&gt;crash&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Quando você usa o operador &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; dentro de uma função &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;, o compilador gera uma máquina de estados que é capaz de pausar a execução do método atual em um determinado ponto, continuar a execução do thread principal e apenas retornar a execução quando a chamada do método terminar. Isso libera o thread principal, permitindo que a tela continue sendo atualizada enquanto você está fazendo a sua operação cara (como acessar a internet ou mudar o tamanho de uma imagem).&lt;/p&gt;

&lt;h3 id=&quot;eu-tenho-um-mtodo-que-pode-ser-assncrono-como-fao&quot;&gt;Eu tenho um método que pode ser assíncrono, como faço?&lt;/h3&gt;

&lt;p&gt;Existe um padrão dentro dos métodos do .net framework que é sempre nomear os métodos que retornam &lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt; com o sufixo Async. Sendo assim, se você tem um método que você considera que pode ser assíncrono, basta verificar se ele já tem uma versão async, como é o caso dos método &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.io.stream.flush%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Flush&lt;/code&gt;&lt;/a&gt; e &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/hh193384%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FlushAsync&lt;/code&gt;&lt;/a&gt;. No caso de Streams e Http, você poderá trabalhar com async sem se preocupar em implementar nada. Basta garantir que seus métodos retornam Tasks e usar await direitinho que tudo funcionará. Já quando você precisa fazer seus próprios métodos assíncronos, existem dois jeitos simples de faze-lo Um é usando &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd449174%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TaskCompletionSource&lt;/code&gt;&lt;/a&gt; e o outro é usando &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.tasks.task.run%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Task.Run&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Uma regra que pode ser seguida é usar o &lt;code class=&quot;highlighter-rouge&quot;&gt;TaskCompletionSource&lt;/code&gt; (TCS) quando você precisa transformar um callback em uma &lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt;. Eu uso muito esse tipo de pattern quando eu preciso de um DialogBox, por exemplo. Você cria uma &lt;code class=&quot;highlighter-rouge&quot;&gt;TaskCompletionSource&amp;lt;bool&amp;gt;&lt;/code&gt;, usa o método &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd449202%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SetResult&lt;/code&gt;&lt;/a&gt; como um callback que é chamado quando o  dialog some e em seguida retorna a &lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt; atrelada ao TCS. Se o usuário clicar em “Ok”, você chama o callback com &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; ou então usa &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; caso contrário. O resultado é um DialogBox que pode ser aguardado.&lt;/p&gt;

&lt;p&gt;Já o &lt;code class=&quot;highlighter-rouge&quot;&gt;Task.Run&lt;/code&gt;serve para você executar um trecha de código (uma &lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;) de forma assíncrona. Esse é um pouco mais difícil de se saber quando usar, portanto lembre-se que &lt;a href=&quot;https://pt.wikipedia.org/wiki/Charles_Antony_Richard_Hoare&quot;&gt;a otimização prematura é a raiz de todo mal&lt;/a&gt;. Por mais tentador que seja, não mude todos os seus métodos para rodar de forma assíncrona indiscriminadamente. Assincronia não deixa o seu código mais rápido, apenas permite que você faça mais coisas por vez.&lt;/p&gt;

&lt;h3 id=&quot;srio-que--fcil-assim&quot;&gt;Sério que é fácil assim?&lt;/h3&gt;

&lt;p&gt;Nem tanto. É importante lembrar que chamadas assíncronas &lt;strong&gt;não garantem a continuação da execução do método no Main Thread&lt;/strong&gt;. Isso quer dizer que, depois que o processamento pesado acabar, seu método pode ou não voltar a ser executado na thread principal. Isso é um perigo, pois existem certas operações que só podem acontecer na main thread (manipulação de uma &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt; que foi inicialmente manipulada no Main Thread é um exemplo). Portanto sempre que for usar métodos assíncronos é importante garantir que a continuação desses métodos pode rodar em uma thread separada.&lt;/p&gt;

&lt;p&gt;Finalizando, sempre que você perceber que seu app está travando sempre no mesmo ponto por estar fazendo trabalho demais na thread principal, considere mudar alguma chamada para &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;. Isso pode te ajudar (e muito). A execução dessa série acaba aqui, então você já pode voltar para a thread principal e continuar acompanhando a série “Mvv O que?”. Até a próxima!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Episódio II - A estrutura de um app MvvmCross</title>
   <link href="http://willsb.github.io/xamarin/2016/02/24/episode-II"/>
   <updated>2016-02-24T00:00:00-03:00</updated>
   <id>http://willsb.github.io/xamarin/2016/02/24/episode-II</id>
   <content type="html">
&lt;p&gt;&lt;img src=&quot;/assets/covers/mvvmwhat.png&quot; alt=&quot;Cover&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;episdio-ii---a-estrutura-de-um-app-mvvmcross&quot;&gt;Episódio II - A estrutura de um app MvvmCross&lt;/h3&gt;

&lt;p&gt;Esse post é a continuação da série sobre MvvmCross em Xamarin. Você pode ler o primeiro episódio, uma introdução ao padrão MVVM e ao MvvmCross, &lt;a href=&quot;/xamarin/2016/02/11/episode-I&quot;&gt;aqui&lt;/a&gt;. Também é recomendada a leitura do artigo &lt;a href=&quot;/xamarin/2016/02/17/episode-I&quot;&gt;Preparando uma PCL para Xamarin&lt;/a&gt;, onde eu explico como funcionam PCLs e alguns problemas comuns que acontecem ao cria-las. O post será mais teórico do que prático e servirá para que vocês entendam melhor como funciona uma aplicação MvvmCross, para não ficar as cegas sobre o funcionamento do framework.&lt;/p&gt;

&lt;h3 id=&quot;por-onde-comear&quot;&gt;Por onde começar?&lt;/h3&gt;

&lt;p&gt;Como visto no post anterior, o MvvmCross irá nos ajudar a separar o código para permitir a maior quantidade de reúso entre plataformas. Isso é alcançado colocando todas as regras de negócio e responsabilidades como navegação, comunicação com API e restauração de estado do app dentro de uma PCL. O padrão de nomenclatura dos apps que usam MvvmCross é sempre o mesmo: Uma PCL chamada &lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].Core&lt;/code&gt; e projetos individuais para cada uma das plataformas, sempre usando o padrão &lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].[Nome da plataforma]&lt;/code&gt;. Os nomes usados para cada plataformas são:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].Core&lt;/code&gt; - PCL compartilhada&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].Droid&lt;/code&gt; - Xamarin.Android&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].IOs&lt;/code&gt; - Xamarin.IOs&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].Mac&lt;/code&gt; -Xamarin.Mac&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].Phone&lt;/code&gt; - Windows Phone&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].Store&lt;/code&gt; - Windows Store&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].UWP&lt;/code&gt; - Universal Windows Platform&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Nome do seu projeto].WPF&lt;/code&gt; - WPF&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ao instalar o pacote nuget &lt;a href=&quot;https://www.nuget.org/packages/MvvmCross.StarterPack/&quot;&gt;MvvmCross.StarterPack&lt;/a&gt;, alguns arquivos serão criados dentro do seu projeto, com base no tipo de projeto em que o pacote foi instalado. Esses arquivos são o mínimo necessário para você começar o seu projeto. No caso de uma PCL, ele irá criar os arquivos &lt;code class=&quot;highlighter-rouge&quot;&gt;App.cs&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;FirstViewModel.cs&lt;/code&gt;, respectivamente o ponto de partida da sua aplicação MvvmCross e uma ViewModel básica de exemplo. No caso de projetos de UI, ele tipicamente criará um arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;Setup.cs&lt;/code&gt;, contendo informações específicas da plataforma sobre o app MvvmCross,  &lt;code class=&quot;highlighter-rouge&quot;&gt;DebugTrace.cs&lt;/code&gt;, que permite customizar o output do console, &lt;code class=&quot;highlighter-rouge&quot;&gt;FirstView.cs&lt;/code&gt;, a View que fará par com a primeira ViewModel e um &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkerPleaseInclude.cs&lt;/code&gt;. Falarei mais sobre esses em outro artigo, pois hoje nós iremos nos focar no &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt; e no &lt;code class=&quot;highlighter-rouge&quot;&gt;Setup&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;o-que-esses-arquivos-fazem&quot;&gt;O que esses arquivos fazem?&lt;/h3&gt;

&lt;p&gt;O arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;App.cs&lt;/code&gt; cria uma classe que estende &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/ViewModels/MvxApplication.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxApplication&lt;/code&gt;&lt;/a&gt;. Essa classe é relativamente simples e é a responsável por auxiliar na customização de algumas partes chave do app. Você &lt;strong&gt;deve&lt;/strong&gt; fazer &lt;em&gt;override&lt;/em&gt; do método &lt;code class=&quot;highlighter-rouge&quot;&gt;Initialize&lt;/code&gt; e dentro dele chamar o método &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterAppStart&lt;/code&gt;. Esse método pode tanto receber um tipo genérico que implemente &lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewModel&lt;/code&gt;, caso onde o Framework sabe que deverá chamar essa ViewModel como a primeira ViewModel do app, assim que tudo for inicializado, quanto uma instancia de uma classe que implemente &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/ViewModels/IMvxAppStart.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxAppStart&lt;/code&gt;&lt;/a&gt;. Aqui, o Framework irá chamar o método &lt;code class=&quot;highlighter-rouge&quot;&gt;Start&lt;/code&gt; dessa interface e ela irá gerenciar qual ViewModel será exibida. Recomenda-se essa segunda alternativa para quando para quando a lógica de inicialização do seu app for mais complexa.&lt;/p&gt;

&lt;p&gt;Já o arquivo &lt;code class=&quot;highlighter-rouge&quot;&gt;Setup.cs&lt;/code&gt; cria uma classe que herda de &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/Platform/MvxSetup.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxSetup&lt;/code&gt;&lt;/a&gt;. A responsabilidade desse tipo é  inicializar o sistema de IoC e chamar a aplicação MvvmCross durante a inicialização do App Nativo. Ele executa uma série de tarefas de inicialização e você pode customizar uma série de componentes fazendo o &lt;em&gt;override&lt;/em&gt; de alguns métodos. Isso é necessário apenas em alguns casos mais específicos. Obrigatoriamente, você deve sobrescrever apenas o método &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateApp&lt;/code&gt; (fazendo com que ele retorno a classe &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt; que existe no Core da aplicação) e com isso você está pronto.&lt;/p&gt;

&lt;h3 id=&quot;por-onde-tudo-isso--inicializado&quot;&gt;Por onde tudo isso é inicializado?&lt;/h3&gt;

&lt;p&gt;Que bom que você perguntou! O MvvmCross usa estratégias diferentes de inicialização para cada uma das plataformas. No Android, por exemplo, você cria uma &lt;code class=&quot;highlighter-rouge&quot;&gt;MvxSplashScreenActivity&lt;/code&gt; e a registra como a primeira Activity do seu programa. Quando ela for inicializada, ela criará o objeto de &lt;code class=&quot;highlighter-rouge&quot;&gt;Setup&lt;/code&gt;, que por sua vez cria o &lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt; MvvmCross e desse ponto em diante, toda a sua navegação já está sendo gerenciada pelo MvvmCross.&lt;/p&gt;

&lt;p&gt;No iOS, você deve usar uma classe que implemente &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/iOS/iOS/Platform/IMvxApplicationDelegate.cs&quot;&gt;IMvxApplicationDelegate&lt;/a&gt; (o jeito mais simples é herdando de  &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/iOS/iOS/Platform/MvxApplicationDelegate.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MvxApplicationDelegate&lt;/code&gt; &lt;/a&gt;). Fazendo isso, ele irá construir o Setup e inicializar o seu app dentro do método &lt;code class=&quot;highlighter-rouge&quot;&gt;FinishedLaunching&lt;/code&gt;.  Nas plataformas da Microsoft, algo similar é feito dentro do &lt;code class=&quot;highlighter-rouge&quot;&gt;App.xaml.cs&lt;/code&gt;: Um &lt;code class=&quot;highlighter-rouge&quot;&gt;Setup&lt;/code&gt; é construído e inicializado junto com a plataforma nativa.&lt;/p&gt;

&lt;p&gt;É importante lembrar que uma vez que o MvvmCross é inicializado, &lt;strong&gt;toda a navegação deve ser gerenciada por ele&lt;/strong&gt; (por meio do método &lt;code class=&quot;highlighter-rouge&quot;&gt;ShowViewModel&lt;/code&gt;). Se você misturar a navegação do MvvmCross com a navegação nativa da plataforma, você eventualmente terá problemas com a gestão do estado do seu app (além de ter que replicar essas navegações em todas as plataformas, já que elas não estarão dentro do código compartilhado). A estrutura de um app MvvmCross é bastante flexível e customizável, portanto se você tiver necessidades específicas de navegação, o ideal é criar um Presenter customizado.&lt;/p&gt;

&lt;h3 id=&quot;navegao-presenter-h&quot;&gt;Navegação? Presenter? Hã?&lt;/h3&gt;

&lt;p&gt;Calma, calma, já me explico. As ViewModels, como previamente explicado, servem para expor propriedades e abstrair o modelo para que as Views exibam uma determinada informação. Eu vou explicar isso melhor no próximo post, quando eu falarei sobre &lt;em&gt;DataBinding&lt;/em&gt;. Agora uma outra funcionalidade chave é o método &lt;code class=&quot;highlighter-rouge&quot;&gt;ShowViewModel&lt;/code&gt;. Chamamos esse método dentro de uma ViewModel quando queremos navegar para outra página¹ do nosso aplicativo. Isso é um jeito simples de controlar a navegação do nosso app e, já que ele fica no Core da aplicação, garante que todas as plataformas exibirão as mesmas informações de forma consistente.&lt;/p&gt;

&lt;p&gt;Para atingir esse objetivo, internamente o método &lt;code class=&quot;highlighter-rouge&quot;&gt;ShowViewModel&lt;/code&gt; faz uso de um objeto que é registrado durante a inicialização do aplicativo. Esse objeto implementa a interface &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross/blob/f7fcf18d960f578b851837f2aaaeb4d0e3b72364/MvvmCross/Core/Core/Views/IMvxViewPresenter.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IMvxViewPresenter&lt;/code&gt;&lt;/a&gt;, que é responsável por definir como cada ViewModel deve ser exibida na tela. O framework vem com implementações de &lt;em&gt;presenters&lt;/em&gt; para as plataformas suportadas (para controlar &lt;em&gt;Activities&lt;/em&gt; e &lt;em&gt;Fragments&lt;/em&gt; no Android, &lt;em&gt;ViewControllers&lt;/em&gt; no iOS e &lt;em&gt;Pages&lt;/em&gt; no Windows Phone, por exemplo).&lt;/p&gt;

&lt;p&gt;Esses &lt;em&gt;Presenters&lt;/em&gt; padrão cobrem a maior parte dos casos. Para ocasiões onde você precisa de algo mais específico, o MvvmCross permite que você estenda esses &lt;em&gt;Presenters&lt;/em&gt; para realizar essas operações sem que a navegação saia de dentro do escopo do Framework.&lt;/p&gt;

&lt;h3 id=&quot;e-agora-o-que-devo-fazer&quot;&gt;E agora, o que devo fazer?&lt;/h3&gt;

&lt;p&gt;Tendo instalado os pacotes necessários e preparado a sua PCL, agora você entende melhor como funciona a estrutura básica de um projeto MvvmCross: Você cria os objetos que inicializam o Framework, usa ViewModels para exibir dados e o método &lt;code class=&quot;highlighter-rouge&quot;&gt;ShowViewModel&lt;/code&gt; cuida da navegação usando os &lt;em&gt;Presenters&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;No próximo artigo nós iremos falar sobre a maneira como as informações da ViewModel são exibidas para o usuários: Falaremos sobre &lt;em&gt;DataBinding&lt;/em&gt;, que é o mecanismo responsável por manter os dados na View atualizados com o da ViewModel. O assunto abrange desde como criar os bindings usando MvvmCross até a explicação da interface que possibilita o padrão MVVM no .net framework, a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.componentmodel.inotifypropertychanged%28v=vs.110%29.aspx&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;INotifyPropertyChanged&lt;/code&gt;&lt;/a&gt;. Portanto fiquem ligados e até a próxima!&lt;/p&gt;

&lt;p&gt;¹ - ViewModels não precisam ser apenas páginas, mas essa é geralmente a associação usada por boa parte dos aplicativos. Falaremos sobre isso mais para frente.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Episódio I - Preparando uma PCL para Xamarin</title>
   <link href="http://willsb.github.io/xamarin/2016/02/17/episode-I"/>
   <updated>2016-02-17T00:00:00-02:00</updated>
   <id>http://willsb.github.io/xamarin/2016/02/17/episode-I</id>
   <content type="html">
&lt;p&gt;&lt;img src=&quot;/assets/covers/pclasync.png&quot; alt=&quot;Cover&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;episdio-i---preparando-uma-pcl-para-xamarin&quot;&gt;Episódio I - Preparando uma PCL para Xamarin&lt;/h3&gt;

&lt;p&gt;Este é um material de apoio que eu publicarei em paralelo à série &lt;a href=&quot;http://willsb.github.io/xamarin/2016/02/11/episode-I&quot;&gt;MVV O que?&lt;/a&gt;. Serão dois posts, onde eu irei ensinar como deixar a sua PCL pronta (além de instruir o que é uma PCL),  e explanar acerca da necessidade de trabalhar com assincronia quando se trata de desenvolvimento Cross-Mobile com Xamarin. Sendo essa uma série assíncrona, as postagens de &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross&quot;&gt;MvvmCross&lt;/a&gt; seguem naturalmente em paralelo :)&lt;/p&gt;

&lt;h3 id=&quot;pcl&quot;&gt;PCL?&lt;/h3&gt;

&lt;p&gt;Portable Class Libraries (PCLs) são tipos específicos de Class Library que podem ser consumidos em multiplos tipos de projeto. Dependendo de como ela é criada, a mesma PCL pode ser utilizada no seu projeto ASP.Net, Windows Phone e até mesmo Android e iOS usando Xamarin. A um conjunto de plataformas, da-se o nom de profile. Mais informação sobre profiles pode ser encontrada &lt;a href=&quot;http://embed.plnkr.co/03ck2dCtnJogBKHJ9EjY/&quot;&gt;aqui&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Quando você cria uma PCL, você escolhe quais plataformas ela vai utilizar. Isso determina quais bibliotecas do .net você poderá usar dentro da sua Class Library, sempre limitando por baixo. Por exemplo: Nenhuma das plataformas móveis tem acesso ao &lt;code class=&quot;highlighter-rouge&quot;&gt;System.IO&lt;/code&gt;. Você pode usar &lt;code class=&quot;highlighter-rouge&quot;&gt;System.IO&lt;/code&gt; em uma PCL que tem como alvo .Net 4.5 e Windows 8, mas ao adicionar Xamarin.Android ou Windows Phone (plataformas que não podem acessar &lt;code class=&quot;highlighter-rouge&quot;&gt;System.IO&lt;/code&gt;), você não pode mais referenciar esse namespace na sua PCL.&lt;/p&gt;

&lt;p&gt;Como a palavra chave do Xamarin é reuso de código, é crucial tentar manter a maior quantidade possível de código dentro de uma PCL que pode ser usada por todas as suas plataformas. Claro que nem todo código pode ser compartilhado (discutiremos isso mais a fundo na série “MVV O que?”), mas quanto mais código estiver na sua PCL, menos tempo você perderá corrigindo bugs através dos dispositivos.&lt;/p&gt;

&lt;h3 id=&quot;e-o-que-pode-ser-compartilhado&quot;&gt;E o que pode ser compartilhado?&lt;/h3&gt;

&lt;p&gt;Uma regra geral é tentar compartilhar tudo que não for referente à camada de visualização. Orquestração da navegação, chamadas de rede, salvamento e recuperação de estado, constantes e até mesmo métodos de extensão que são pertinentes a todas plataformas podem e devem ser incluídos na sua PCL.&lt;/p&gt;

&lt;p&gt;Dos exemplos acima, o que sem dúvidas é o maior facilitador é a parte de chamadas de rede. Mesmo que sua aplicação Xamarin não faça uso do padrão MVVM, deixar toda a parte de comunicação com APIs do seu app disponível em uma PCL é algo fundamental. Digo isso porque as chamadas à rede seguem um padrão que independe da plataforma: Você faz uma requisição, o servidor serve uma resposta e você faz algo com esse resultado.&lt;/p&gt;

&lt;p&gt;Ao fazer toda a parte de rede em uma PCL, você consegue colocar todo o tratamento de erros e transformação dos dados em um único lugar. Alteração na API? Bug no client? Comportamento deve ser alterado? Tudo se resolve em todas as suas aplicações ao mudar uma unica chamada. Legal, né?&lt;/p&gt;

&lt;h3 id=&quot;e-como-faz-para-brincar-disso&quot;&gt;E como faz para brincar disso?&lt;/h3&gt;

&lt;p&gt;Criar um projeto de PCL é simples. No VS15, sigo o caminho File &amp;gt; New Project &amp;gt; Visual C# &amp;gt; Windows &amp;gt; Class Library (Portable). Após selecionar o local de criação, você verá uma lista com as plataformas possíveis. Escolha as que você pretende usar e clique em ok.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pcl-sample.png&quot; alt=&quot;Exemplo de criação de PCL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Algo que costuma causar um certo pânico é o fato de que alguns targets de PCL não tem acesso ao namespace &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Net.Http&lt;/code&gt; e nem tem suporte a operações assíncronas (a tabela de quais são esses targets pode ser encontrada &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/gg597391(v=vs.110).aspx#Anchor_4&quot;&gt;aqui&lt;/a&gt;). Para resolver esse problema, você deve instalar alguns pacotes NuGet que irão permitir o uso dessas libs. Os pacotes são o &lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Bcl.Async/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Microsoft.Bcl.Async&lt;/code&gt;&lt;/a&gt; e o &lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Net.Http&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Microsoft.Net.Http&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Feito isso, sua PCL está pronta para se tornar o ponto de inicio do seu projeto! No próximo post desta série, Irei falar sobre a importancia de usar assíncronia e o quanto isso é facilitado ao usar Xamarin, então fiquem ligados e até a próxima!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>await willsb.PreparePCLAsync();</title>
   <link href="http://willsb.github.io/xamarin/2016/02/16/index"/>
   <updated>2016-02-16T00:00:00-02:00</updated>
   <id>http://willsb.github.io/xamarin/2016/02/16/index</id>
   <content type="html">
&lt;p&gt;Esse post é um indexador para a série “await willsb.PreparePCLAsync();”.&lt;/p&gt;

&lt;h3 id=&quot;episdio-i---preparando-uma-pcl-para-xamarinxamarin20160217episode-i&quot;&gt;&lt;a href=&quot;/xamarin/2016/02/17/episode-I&quot;&gt;Episódio I - Preparando uma PCL para Xamarin&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;episdio-ii---a-importncia-de-usar-asyncxamarin20160302episode-ii&quot;&gt;&lt;a href=&quot;/xamarin/2016/03/02/episode-II&quot;&gt;Episódio II - A importância de usar async&lt;/a&gt;&lt;/h3&gt;

</content>
 </entry>
 
 <entry>
   <title>Episódio I - Introdução à MVVM e MvvmCross</title>
   <link href="http://willsb.github.io/xamarin/2016/02/11/episode-I"/>
   <updated>2016-02-11T00:00:00-02:00</updated>
   <id>http://willsb.github.io/xamarin/2016/02/11/episode-I</id>
   <content type="html">
&lt;p&gt;&lt;img src=&quot;/assets/covers/mvvmwhat.png&quot; alt=&quot;Cover&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;episdio-i---introduo--mvvm-e-mvvmcross&quot;&gt;Episódio I - Introdução à MVVM e MVVMCross&lt;/h3&gt;

&lt;p&gt;Este é o primeiro post de uma série de chamada “MVV o que?”. Nesta série eu irei falar do padrão MVVM (Model-View-ViewModel) aplicado em ambiente Android/Windows Phone usando Xamarin. Neste primeiro post, irei falar de conceitos básicos de Xamarin e explicar um pouco do Framework que será utilizado nos exemplos, o &lt;a href=&quot;https://github.com/MvvmCross/MvvmCross&quot;&gt;MvvmCross&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A motivação para a criação deste conteúdo é a carência de fontes sobre esse tema em português e a falta de pontos de início para os estudos de Xamarin como um todo. Acompanhando a comunidade Xamarin (no StackOverflow e no grupo &lt;a href=&quot;https://www.facebook.com/groups/MonkeyNightsDevs/&quot;&gt;Monkey Nights Devs&lt;/a&gt;, entre outros lugares) percebe-se que muitos desenvolvedores vêm de um background Android ou simplesmente desconhecem o padrão MVVM, que é amplamente difundido no .Net.&lt;/p&gt;

&lt;p&gt;Minha abordagem tentará ser menos formal do que minhas resposta no StackOverflow, porém sem jamais perder detalhes importantes ao entendimento. Afinal, se o objetivo fosse parafrasear a definição de MVVM da Wikipedia, não tem motivo para estar aqui. Now let’s get down to business!&lt;/p&gt;

&lt;h3 id=&quot;o-que--mvvm-mesmo&quot;&gt;O que é MVVM mesmo?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Disclaimer - Esses são conceitos teóricos básicos com o objetivo de conceituar quem nunca ouviu falar de MVVM. Se você já tem familiaridade com esse padrão, pode pular essa parte inteira sem perder nada.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Model-View-ViewModel (MVVM) é um padrão criado por engenheiros da Microsoft com o objetivo de facilitar o desacoplamento das responsabilidades de UI e lógica de negócios durante o processo de desenvolvimento de Software. Programas escritos usando esse padrão são idealmente testáveis e de fácil manutenção. Para mais informação histórica sobre MVVM (que não é o objetivo desse post), você pode consultar &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/hh848246.aspx&quot;&gt;esta página&lt;/a&gt;, da própria Microsoft&lt;/p&gt;

&lt;p&gt;A maneira como o padrão funciona pode ser explicada de forma relativamente simples. Os models são a representação dos seus dados na base. ViewModels (VM) são abstrações que tem como intuito expor apenas o que é necessário para que as Views, que são a camada de apresentação, exibam os dados na tela com facilidade. Sendo assim, os dados (models) são moldados para gerar ViewModels que são usadas pelas Views para exibir os dados na tela. Por mais simples que pareça, essa separação fornece grandes benefícios.&lt;/p&gt;

&lt;p&gt;Um deles é a facilidade de testar. ViewModels são classes independentes da interação do usuário. Isso quer dizer que escrever testes de unidade para elas é simples (e bastante aconselhável). Isso nos leva a um outro ponto crucial para o MVVM casar com o Xamarin: as ViewModels são independentes das Views. Idealmente, ViewModels nem sabem que uma View existe, portanto a mesma ViewModel pode ser usada por mais de uma interface!&lt;/p&gt;

&lt;p&gt;“Legal, uma VM serve para muitas Views. E dai?”, você se pergunta. A resposta é: Essa é exatamente a proposta do Xamarin! Reúso do mesmo código para gerar apps em muitas plataformas. Ou seja, uma ViewModel escrita em C# pode reger as Views que vão ser usadas no seu app Android, iOS e Windows Phone! Wow!&lt;/p&gt;

&lt;h3 id=&quot;e-como-isso-tudo-funciona-com-xamarin&quot;&gt;E como isso tudo funciona com Xamarin?&lt;/h3&gt;

&lt;p&gt;É importante lembrar que MVVM é apenas um padrão. Precisamos de um framework que implemente este padrão para coloca-lo em prática. Existem inúmeros frameworks de MVVM disponíveis. O que usaremos durante essa série é o MvvmCross, que é um framework bastante completo e que funciona muito bem com Xamarin. Os conceitos de MVVM que você aprenderá, contudo, são aplicáveis a qualquer outro framework.&lt;/p&gt;

&lt;p&gt;Quando se usa MvvmCross, você precisará de um projeto Core, que é onde ficará toda a lógica compartilhada entre as plataformas que você usará (ou seja, ViewModels e Models) e um projeto específico para cada plataforma que você irá utilizar. Sendo assim, uma estrutura que vai funcionar em Windows Phone, iOS e Android terá, no mínimo, 4 projetos.&lt;/p&gt;

&lt;p&gt;Usar o MVVMCross na prática é super simples. Basta instalar o pacote &lt;a href=&quot;https://www.nuget.org/packages/MvvmCross.StarterPack/&quot;&gt;MvvmCross.StarterPack&lt;/a&gt; em cada um dos seus projetos e ele criará uma estrutura mínima para começar o seu projeto. O assunto do próximo post será justamente esse: Entendendo a estrutura de um app MvvmCross.&lt;/p&gt;

&lt;h3 id=&quot;tem-que-pagar-alguma-coisa&quot;&gt;Tem que pagar alguma coisa?&lt;/h3&gt;

&lt;p&gt;O MvvmCross é 100% gratuito e de código aberto. Você pode olhar o código, modifica-lo e usar o quanto quiser, sem pagar nada. O Xamarin, contudo, não é. Se quiser usar seu código para fazer aplicativos para Android ou iOS, você terá que pagar a licença do Xamarin. Sobre o funcionamento das licenças, &lt;a href=&quot;http://xamarinbr.azurewebsites.net/entendendo-as-licencas-do-xamarin/&quot;&gt;este post&lt;/a&gt;, do Angelo Belchior, explica muito bem o funcionamento e os valores de cada modalidade.&lt;/p&gt;

&lt;p&gt;Mesmo sem ter acesso à uma conta Xamarin paga, você pode iniciar um período de 30 dias de trial para praticar com apps Android/iOS e os exemplos usados aqui irão sempre cobrir UWP (Universal Windows Platform) para que todos possam aprender :)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MVV O que? - MVVM aplicado à Xamarin</title>
   <link href="http://willsb.github.io/xamarin/2016/02/10/index"/>
   <updated>2016-02-10T00:00:00-02:00</updated>
   <id>http://willsb.github.io/xamarin/2016/02/10/index</id>
   <content type="html">
&lt;p&gt;Esse post é um indexador para a série “MVV O que? - MVVM aplicado à Xamarin”.&lt;/p&gt;

&lt;h3 id=&quot;episdio-i---introduo--mvvm-e-mvvmcrossxamarin20160211episode-i&quot;&gt;&lt;a href=&quot;/xamarin/2016/02/11/episode-I&quot;&gt;Episódio I - Introdução à MVVM e MvvmCross&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;episdio-ii---a-estrutura-de-um-app-mvvmcrossxamarin20160224episode-ii&quot;&gt;&lt;a href=&quot;/xamarin/2016/02/24/episode-II&quot;&gt;Episódio II - A estrutura de um app MvvmCross&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;episdio-iii---data-binding-em-mvvmcross-101xamarin20160314episode-iii&quot;&gt;&lt;a href=&quot;/xamarin/2016/03/14/episode-III&quot;&gt;Episódio III - Data Binding em MvvmCross 101&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;episdio-iv---data-binding-em-mvvmcross-102xamarin20160403episode-iv&quot;&gt;&lt;a href=&quot;/xamarin/2016/04/03/episode-IV&quot;&gt;Episódio IV - Data Binding em MvvmCross 102&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&quot;episdio-v---navegao-usando-mvvmcrossxamarin20160423episode-v&quot;&gt;&lt;a href=&quot;/xamarin/2016/04/23/episode-V&quot;&gt;Episódio V - Navegação usando MvvmCross&lt;/a&gt;&lt;/h3&gt;

</content>
 </entry>
 
 
</feed>
